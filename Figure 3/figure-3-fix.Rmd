```{r}
library(dplyr); library(imager); library(reshape2); library(matlab); 
library(ggplot2); library(latex2exp); library(cowplot); library(igraph);
library(reshape2); np = reticulate::import("numpy")
```

Define a function that will load the training image.

```{r}
load_memory_image = function(fname, size=100) {
  im = png::readPNG(fname)
  im_arr = array(NA, dim=c(dim(im)[1], dim(im)[2], 1, 1))
  im_arr[,,1,1] = im[,,1]
  im = resize(im_arr, size_x=sqrt(size), size_y=sqrt(size), size_z=1, size_c=1)
  im = im[,,1,1] %>% rot90() %>% rot90() %>% rot90()
  im[im<=0] = -1
  im[im>0] = 1
  return(im)
}
```

Define a function that will initialize the network object. All opperation will be applied to the network object.

```{r}
create_network = function(n_units=100, p_connection=.2) {
  synapses = replicate(n_units, rbinom(n_units, 1, p_connection)) == 1
  weights = matrix(0, n_units, n_units)
  net = list(
    synapses = synapses,
    weights = weights,
    membrane_potentials = NULL,
    firing_rates = NULL
  )
  return(net)
}
```

Define a function that will train the network. The training image is supplied as the current I, and weights are updated on every time step.

```{r}
train_network = function(net, I) {
  weights = np$dot(t(I), I)
  weights[net$synapses == F] = 0
  net$weights = weights
  return(net)
}
```

Define a funciton that will perform synapse turnover and adjust weights appropriately.

```{r}
# synapse turnover, replace synapses and update weights appropriately
turnover = function(net, turnover, weight_range=c(-1, 1)) {
  synapses = net$synapses
  weights = net$weights
  
  # turnover synapses
  lost_synapses = which(synapses == T) %>% sample(turnover)
  synapses[lost_synapses] = F
  new_synapses = which(synapses == F) %>% sample(turnover)
  synapses[new_synapses] = T
  
  # turnover weights
  weights[lost_synapses] = 0
  weights[new_synapses] = runif(length(new_synapses), weight_range[1], weight_range[2])
  
  net$synapses = synapses
  net$weights = weights
  return(net)
}
```

Define a function that will perform reactivation. One reactivation consists of initialization with random membrane potentials, updating Vm for 12 time steps, then updating weights.

```{r}
reenter = function(net) {
  n_units = nrow(net$weights)
  net$membrane_potentials = runif(n_units, min=-0.004, max=0.004) %>% matrix(1, n_units)
  net$firing_rates = tanh(net$membrane_potentials)
  for (i in 1:12) {
    X = net$firing_rates
    net$membrane_potentials = -net$membrane_potentials + np$dot(X, net$weights)
    net$firing_rates = tanh(net$membrane_potentials)
  }
  X = net$firing_rates
  new_weights = np$dot(t(X), net$firing_rates)
  new_weights[net$synapses == F] = 0
  net$weights = new_weights
  return(net)
}
```

Define a function that will run the simulation, returning a dataframe with r-squared values and parameters.

```{r}
# Simulation function
simulation = function(n_units, turnover_rate, p_connection) {
  # Initialization and training
  net = create_network(n_units=n_units, p_connection=p_connection)
  I = load_memory_image("training-images/creeper.png", size=n_units) %>% matrix(1, n_units)
  net = train_network(net, I)
  # Reactivations and statistics
  r_squared_1 = 0 # to save
  for (i in 1:100) {
    n_turnover = floor(turnover_rate * sum(sum(net$synapses)))
    net = turnover(net, turnover=n_turnover)
    net = reenter(net)
    if (i == 1) r_squared_1 = cor(c(I), c(net$firing_rates))^2 # save
  }
  r_squared_100 = cor(c(I), c(net$firing_rates))^2
  # Find median indegree
  graph_obj = graph_from_adjacency_matrix(net$synapses, mode="directed")
  indegree = degree(graph_obj, mode="in") %>% median()
  
  # Collect results
  df = data.frame(
    n_units = n_units,
    turnover_rate = turnover_rate,
    p_connection = p_connection,
    indegree = indegree,
    r_squared = c(r_squared_1, r_squared_100),
    reactivation = c("1", "100"),
    stringsAsFactors = F
    )
  return(df)
}
```

Run the simulation, varying the probability of connection.

```{r}
set.seed(198273)

n = 100
parameters = data.frame(
  n_units = 100,
  turnover_rate = .1,
  p_connection = runif(n, .1, .9)
  )

df_result_pconnection = sapply(1:n, function(i) {
  do.call(simulation, as.list(parameters[i,]))
}, simplify=F) %>%
  bind_rows()

g_pconnection = df_result_pconnection %>%
  ggplot(aes(p_connection, r_squared, color=reactivation)) +
  geom_point() +
  #geom_smooth(aes(fill=reactivation), method="loess", span=.5, color=NA) +
  coord_cartesian(ylim=c(0, 1)) +
  scale_color_manual(values=c("blue3", "red3")) +
  scale_fill_manual(values=c("blue3", "red3")) +
  labs(x="Probability of connection", y=TeX("r^2"))
g_pconnection
```

Run the simulation, varying the turnover rate.

```{r}
set.seed(877324)

n = 100
parameters = data.frame(
  n_units = 225,
  turnover_rate = runif(n, 0, 1),
  p_connection = .4
  )

df_result_turnover = sapply(1:n, function(i) {
  do.call(simulation, as.list(parameters[i,]))
}, simplify=F) %>%
  bind_rows()

g_turnover = df_result_turnover %>%
  ggplot(aes(turnover_rate*100, r_squared, color=reactivation)) +
  geom_point() +
  geom_smooth(aes(fill=reactivation), method="loess", span=.5, color=NA) +
  coord_cartesian(ylim=c(0, 1)) +
  scale_color_manual(values=c("blue3", "red3")) +
  scale_fill_manual(values=c("blue3", "red3")) +
  labs(x="Turnover rate [%]", y=TeX("r^2"))
g_turnover
```

Run the simulation, varying the number of units.

```{r}
set.seed(92823)

n = 100
parameters = data.frame(
  n_units = sample(c(4:30)^2, n, replace=T),
  turnover_rate = .1,
  p_connection = .3
  )

df_result_nunits = sapply(1:n, function(i) {
  do.call(simulation, as.list(parameters[i,]))
}, simplify=F) %>%
  bind_rows()

g_nunits = df_result_nunits %>%
  ggplot(aes(n_units, r_squared, color=reactivation)) +
  geom_point() +
  geom_smooth(aes(fill=reactivation), method="loess", span=.5, color=NA) +
  coord_cartesian(ylim=c(0, 1)) +
  scale_color_manual(values=c("blue3", "red3")) +
  scale_fill_manual(values=c("blue3", "red3")) +
  labs(x="# of units", y=TeX("r^2"))
g_nunits
```

Run the simulation, varying all parameters.

```{r}
set.seed(98174)

n = 100
parameters = data.frame(
  n_units = sample(c(16:64)^2, n, replace=T),
  turnover_rate = runif(n, 0, 1),
  p_connection = runif(n, .1, .9)
  )

df_result_indegree = sapply(1:n, function(i) {
  do.call(simulation, as.list(parameters[i,]))
}, simplify=F) %>%
  bind_rows()

g_indegree = df_result_indegree %>%
  filter(reactivation == "100") %>%
  ggplot(aes(indegree, turnover_rate*100, color=r_squared)) +
  geom_point() +
  scale_color_distiller(palette="Spectral") +
  labs(x="Median in-degree", y="Turnover rate [%]", color=TeX("r^2"))
g_indegree
```

Define a function that generates representative images of the networks.

```{r}
# Simulation function
simulation_representative = function(n_units, turnover_rate, p_connection) {
  
  # Initialization and training
  net = create_network(n_units=n_units, p_connection=p_connection)
  I = load_memory_image("training-images/creeper.png", size=n_units) %>% matrix(1, n_units)
  net = train_network(net, I)
  
  # Reactivations and statistics
  firing_rates_activation_1 = NULL # to save
  for (i in 1:100) {
    n_turnover = floor(turnover_rate * sum(sum(net$synapses)))
    net = turnover(net, turnover=n_turnover)
    net = reenter(net)
    if (i == 1) firing_rates_activation_1 = net$firing_rates # save
  }
  
  # Collect results
  df = bind_rows(
    firing_rates_activation_1 %>% 
      matrix(n_units^.5, n_units^.5) %>%
      melt() %>%
      mutate(Reactivation = "1"),
    net$firing_rates %>% 
      matrix(n_units^.5, n_units^.5) %>%
      melt() %>%
      mutate(Reactivation = "100")
    ) %>%
    mutate(
      n_units = n_units, 
      turnover_rate = turnover_rate, 
      p_connection = p_connection
      )
  
  return(df)
}
```

```{r}
set.seed(42344)

df_rep = bind_rows(
    simulation_representative(n_units=64, turnover_rate=.1, p_connection=.3),
    simulation_representative(n_units=144, turnover_rate=.1, p_connection=.3),
    simulation_representative(n_units=225, turnover_rate=.1, p_connection=.3)
  )

g_rep_nunits = ggplot(df_rep, aes(Var1, Var2, fill=value)) +
  facet_grid(Reactivation~n_units) +
  geom_raster() +
  scale_fill_gradient2(high="black", mid="white", low="wheat3") +
  coord_equal() +
  theme_classic() +
  theme(
    axis.line = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    strip.background = element_blank(),
    text=element_text(size=8)
  ) +
  scale_x_continuous(position="top") +
  labs(x="# of units", y="Reactivation #", fill=TeX("r^2"))
g_rep_nunits
```

```{r}
set.seed(92834)

df_rep = bind_rows(
    simulation_representative(n_units=400, turnover_rate=.1, p_connection=.3),
    simulation_representative(n_units=400, turnover_rate=.5, p_connection=.3),
    simulation_representative(n_units=400, turnover_rate=.75, p_connection=.3)
  )

g_rep_turnover = ggplot(df_rep, aes(Var1, Var2, fill=value)) +
  facet_grid(Reactivation~turnover_rate, switch="y") +
  geom_raster() +
  scale_fill_gradient2(high="black", mid="white", low="wheat3") +
  coord_equal() +
  theme_classic() +
  theme(
    axis.line = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    strip.background = element_blank(),
    text=element_text(size=8)
  ) +
  scale_x_continuous(position="top") +
  labs(x="Turnover rate", y="Reactivation #", fill=TeX("r^2"))
g_rep_turnover
```

```{r}
set.seed(572345)

df_rep = bind_rows(
    simulation_representative(n_units=144, turnover_rate=.1, p_connection=.2),
    simulation_representative(n_units=144, turnover_rate=.1, p_connection=.3),
    simulation_representative(n_units=144, turnover_rate=.1, p_connection=.4)
  )

g_rep_pconnection = ggplot(df_rep, aes(Var1, Var2, fill=value)) +
  facet_grid(Reactivation~p_connection, switch="y") +
  geom_raster() +
  scale_fill_gradient2(high="black", mid="white", low="wheat3") +
  coord_equal() +
  theme_classic() +
  theme(
    axis.line = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    strip.background = element_blank(),
    text=element_text(size=8)
  ) +
  scale_x_continuous(position="top") +
  labs(x="Probability of connection", y="Reactivation #", fill=TeX("r^2"))
g_rep_pconnection
```

Define a function that generates representative changes in membrane potentials.

```{r}
reenter_return_firing_rates = function(net) {
  n_units = nrow(net$weights)
  net$membrane_potentials = runif(n_units, min=-0.004, max=0.004) %>% matrix(1, n_units)
  net$firing_rates = tanh(net$membrane_potentials)
  net$firing_rates_all_timesteps = matrix(0, 13, n_units)
  net$firing_rates_all_timesteps[1,] = net$firing_rates
  for (i in 1:12) {
    X = net$firing_rates
    net$membrane_potentials = -net$membrane_potentials + np$dot(X, net$weights)
    net$firing_rates = tanh(net$membrane_potentials)
    net$firing_rates_all_timesteps[i+1,] = net$firing_rates
  }
  X = net$firing_rates
  new_weights = np$dot(t(X), net$firing_rates)
  new_weights[net$synapses == F] = 0
  net$weights = new_weights
  return(net)
}

# Simulation function
simulation_dVm = function(n_units, turnover_rate, p_connection) {
  
  # Initialization and training
  net = create_network(n_units=n_units, p_connection=p_connection)
  I = load_memory_image("training-images/creeper.png", size=n_units) %>% matrix(1, n_units)
  net = train_network(net, I)
  # Reactivations and statistics
  firing_rates = matrix(0, 1, n_units) # to save
  for (i in 1:5) {
    n_turnover = floor(turnover_rate * sum(sum(net$synapses)))
    net = turnover(net, turnover=n_turnover)
    net = reenter_return_firing_rates(net)
    firing_rates = rbind(firing_rates, net$firing_rates_all_timesteps) # save
  }
  r_squared = apply(firing_rates, 1, function(rate) cor(rate, c(I))^2)
  # Gather results
  result_list = list(
    firing_rates = firing_rates,
    r_squared = r_squared
  )
  return(result_list)
}
```

```{r}
results_list = simulation_dVm(n_units=225, turnover_rate=.6, p_connection=.3)
for (i in 1:nrow(results_list$firing_rates)) {
  if ((i-1) %% 13 == 0) {
    results_list$firing_rates[i,] = rep(NA, 225)
    results_list$r_squared[i] = NA
  }
}


g_attractor_dynamics = results_list$firing_rates %>%
  diff() %>%
  melt() %>%
  ggplot(aes(Var1, value, group=Var2)) +
  geom_line() +
  annotate(
    "line",
    x=1:length(results_list$r_squared), 
    y=results_list$r_squared/2+1.1,
    color="red"
    )
g_attractor_dynamics
```


```{r, fig.height=4, fig.width=6.18}
theme_set(
  theme_classic() +
    theme(
      text=element_text(size=8),
      strip.text=element_text(size=8)
      )
  )
legend_top = get_legend(g_turnover)
legend_middle = get_legend(g_rep_turnover)
no_legend = theme(legend.position = "none")
figure = ggdraw() +
  # top row
  draw_plot(g_turnover + no_legend, x=0, y=2/3, width=1/3, height=1/3) +
  draw_plot(g_pconnection + no_legend, x=1/3, y=2/3, width=1/3, height=1/3) +
  draw_plot(g_nunits + no_legend, x=2/3, y=2/3, width=1/3, height=1/3) +
  # middle row
  draw_plot(g_rep_turnover + no_legend, x=0, y=1/3, width=1/3, height=1/3) +
  draw_plot(g_rep_pconnection + no_legend, x=1/3, y=1/3, width=1/3, height=1/3) +
  draw_plot(g_rep_nunits + no_legend, x=2/3, y=1/3, width=1/3, height=1/3) +
  # bottom row
  draw_plot(g_indegree + no_legend, x=0, y=0, width=1/2, height=1/3) +
  draw_plot(g_attractor_dynamics + no_legend, x=1/2, y=0, width=1/2, height=1/3) +
  # labels
  draw_plot_label(
    LETTERS[1:8], 
    x=c(0,1/3, 2/3,0,1/3, 2/3,0,1/2), 
    y=c(1,1,1,2/3,2/3,2/3,1/3,1/3),
    size=10
    )

tiff("test.tiff", width=6.18, height=5, units="in", res=300)
figure
dev.off()
```

