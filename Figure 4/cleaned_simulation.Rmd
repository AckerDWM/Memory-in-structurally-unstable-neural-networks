# Define simulations

First import functions defined in a seperate file that do the individual processes that will make up the simulations.

```{r}
source("methods-comparing-architectures.R")
```

Define a function that runs the simulation experiments.

```{r}
simulate = function(n_patterns, interleaved, activation_method, turnover_percentage) {
  # Initialize network
  net = create_network(n_units=100, n_inputs=1000, n_patterns=n_patterns)
  
  # Establish initial bias
  net = activate(net=net, activation_method=activation_method)
  net = update_weights(net=net)
  y_activation_1 = net$y # result
  
  # Reactivate
  n_activations = 99
  if (interleaved) {
    n_activations = adjust_activations_interleaving(n_activations, n_patterns)
    turnover_percentage = adjust_turnover_interleaving(turnover_percentage, n_patterns)
  }
  X = net$X
  for (i in 1:n_activations) {
    if (interleaved & i < n_activations) { # cycle through patterns one-by-one
      net$X = X[( (i-1) %% n_patterns ) + 1, ,drop=F]
    } else {
      net$X = X
    }
    n_turnover = floor(turnover_percentage*sum(sum(net$synapses)))
    net = turnover(net=net, turnover=n_turnover)
    net = activate(net=net, activation_method=activation_method)
    net = update_weights(net=net)
  }
  y_activation_100 = net$y # result
  
  # Collect results
  result_list = list(
    y_activation_1=y_activation_1, 
    y_activation_100=y_activation_100
    )
  
  return(result_list)
}
```

Define a function that runs the simulation and extracts the memory metrics autocorrelation and unqueness.

```{r}
memory_measurements = function(
  n_patterns, interleaved, activation_method, turnover_percentage, replicate) {
  # Run simulation
  result_list = simulate(
    n_patterns=n_patterns, 
    interleaved=interleaved, 
    activation_method=activation_method, 
    turnover_percentage=turnover_percentage
    )
  
  # Calculate memory measurements
  autocor = get_autocorrelation(result_list$y_activation_1, result_list$y_activation_100)
  uniqueness = get_uniqueness(result_list$y_activation_1, result_list$y_activation_100)
  
  # Collect results
  df = data.frame(
    Autocor = autocor,
    Uniqueness = uniqueness,
    Patterns = n_patterns,
    Interleaved = ifelse(interleaved, "Interleaved\nupdates", "Simultaneous\nupdates"),
    Activation_method = activation_method,
    Turnover = turnover_percentage,
    Replicate = replicate,
    stringsAsFactors = F
  )
  
  return(df)
}
```

Define a function that runs the simulation and collects correlation matrices relating responses on activations 1 and 100.

```{r}
get_correlations = function(
  n_patterns, interleaved, activation_method, turnover_percentage, replicate) {
  
  # Run simulation
  result_list = simulate(
    n_patterns=n_patterns, 
    interleaved=interleaved, 
    activation_method=activation_method, 
    turnover_percentage=turnover_percentage
    )
  
  # Extract correlation matrix
  correlations = cor(t(result_list$y_activation_1), t(result_list$y_activation_100))
  df_correlations = melt(correlations) %>%
    mutate(
      Interleaved=ifelse(interleaved, "Interleaved\nupdates", "Simultaneous\nupdates"),
      Activation_method=activation_method
      )
  
  return(df_correlations)
}
```

# Run simulations and collect data

Run simulations to collect representative correlation matrices. Simulations will include 5 patterns and a 10% basal turnover rate. Interleaving and activation method will vary.

```{r}
set.seed(1234)

parameter_grid = list(
  n_patterns=5,
  interleaved=c(F, T),
  activation_method=c("Identity", "Winner-takes-all", "E%-max"),
  turnover_percentage = .1,
  replicate=1
) %>%
  expand.grid()

df_representative = sapply(1:nrow(parameter_grid), function(i) {
  do.call(get_correlations, as.list(parameter_grid[i,]))
}, simplify=F) %>%
  bind_rows()
```

Run simulations to collect memory metrics. Interleaving, number of patterns, turnover rate, and activation method will vary. There will be 10 replicates of each combination. This will take a long time (>1 hour).

```{r}
set.seed(1234)

parameter_grid = list(
  n_patterns=c(5, 25, 50, 100),
  interleaved=c(F, T),
  activation_method=c("Identity", "Winner-takes-all", "E%-max"),
  turnover_percentage = c(0, .1),
  replicate=1:10
) %>%
  expand.grid()

df_results = sapply(1:nrow(parameter_grid), function(i) {
  do.call(memory_measurements, as.list(parameter_grid[i,]))
}, simplify=F) %>%
  bind_rows()

df_results = df_results %>%
  mutate(Interleaved = factor(Interleaved, levels=c(
    "Simultaneous\nupdates", "Interleaved\nupdates"
  ))) %>%
  mutate(Turnover = ifelse(Turnover==0, "0%", "10%"))
```

# Plotting

Generate graphs and combine them into a figure. This will be figure 4 in the manuscript.

```{r}
g_autocor = ggplot(df_results, aes(Patterns, Autocor, color=factor(Turnover))) +
  facet_grid(Interleaved~Activation_method) +
  geom_line(stat="summary", fun.data="mean_se") +
  geom_errorbar(stat="summary", fun.data="mean_se", width=15) +
  geom_point(stat="summary", fun.data="mean_se") +
  geom_hline(yintercept=0, lty=2) +
  scale_color_manual(values=c("blue", "orange")) +
  scale_x_continuous(breaks=c(5, 25, 50, 100)) +
  labs(x="# of patterns", y="Autocorrelation", color="Turnover rate")

g_unique = ggplot(df_results, aes(Patterns, Uniqueness, color=factor(Turnover))) +
  facet_grid(Interleaved~Activation_method) +
  geom_line(stat="summary", fun.data="mean_se") +
  geom_errorbar(stat="summary", fun.data="mean_se", width=15) +
  geom_point(stat="summary", fun.data="mean_se") +
  geom_hline(yintercept=0, lty=2) +
  scale_color_manual(values=c("blue", "orange")) +
  scale_x_continuous(breaks=c(5, 25, 50, 100)) +
  labs(x="# of patterns", y="Uniqueness", color="Turnover rate")

g_representative = df_representative %>%
  mutate(Interleaved = factor(Interleaved, levels=c(
    "Simultaneous\nupdates", "Interleaved\nupdates"
  ))) %>%
  ggplot(aes(Var1, Var2, fill=value)) +
    facet_grid(Activation_method~Interleaved) +
    geom_raster() +
    scale_fill_gradient2(low="cyan", mid="white", high="magenta", limits=c(-1, 1)) +
    coord_equal() +
    labs(x="Response, reactivation 1", y="Response, reactivation 100", fill="r") +
    guides(fill=guide_colorbar(barheight=.5)) +
    theme(legend.position = "bottom")

theme_set(
  theme_classic() +
    theme(
      text=element_text(size=8),
      strip.background = element_blank(),
      strip.text=element_text(size=6)
      )
  )

legend = get_legend(g_autocor+guides(color=guide_legend(nrow=2)))
no_legend = theme(legend.position = "none")
figure = ggdraw() +
  draw_plot(g_autocor + no_legend, x=0, y=.5, width=.5, height=.5) +
  draw_plot(g_unique + no_legend, x=0, y=0, width=.5, height=.5) +
  draw_plot(legend, x=.5, y=0, width=2/3-.5, height=1) +
  draw_plot(g_representative, x=2/3, y=0, width=1/3, height=1) +
  draw_plot_label(label=LETTERS[1:3], x=c(0, 0, 2/3), y=c(1, .5, 1), size=10)

tiff("figure-4.tiff", width=6.18, height=3.5, units="in", res=300)
figure
dev.off()
```


